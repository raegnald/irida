///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                        Irida's Standard Library                           //
//                            [Ronaldo Gligan]                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
// C standard input/output bindings
// Convinient procedures
// ...

proc nothing () ()
| nop
end

proc id ~ ~ end

// Stack operations

proc drop (~) ()
// ABC -> BC
| pop rax
end

proc ddrop (~, ~) ()
// ABC -> C
  drop drop
end

proc dropd (~, ~) ~
// ABC -> AC
// Drop down; pops the penultimate element that's on top
  swap drop
end

proc dropdd (~, ~, ~) ~
// ABC -> A
  swap third ddrop
end

proc dupl (~) (~, ~)
// A -> AA
| pop rax
| push rax
| push rax
end

proc ddupl (~) (~, ~, ~)
// A -> AAA
  dupl dupl
end

proc swap (~, ~) (~, ~)
// AB -> BA
| pop rax
| pop rbx
| push rax
| push rbx
end

proc third (~, ~, ~) (~, ~, ~)
// ABC -> CAB
// Gets the third last element of the stack and moves it on top
| pop rax
| pop rbx
| pop rcx
| push rbx
| push rax
| push rcx
end

// Stack extended operations

proc sDts (~, ~, ~) (~, ~, ~, ~)
// ABC -> BABC
  swap dupl third swap
end

proc Dt (~, ~, ~) (~, ~, ~, ~)
// ABC -> BAAC
  dupl third
end

proc st (~, ~, ~) (~, ~, ~)
// ABC -> CBA
  swap third
end


// Procedures on strings

proc lens str int
| extern strlen
| pop rdi
| call strlen
| push rax
end
proc strlen str int lens end


// Procedures on integers

proc is_even int int
  mod: 2 eq: 0
end

proc is_odd int int
  mod: 2 not % eq: 0;
end

proc itos int str
// Integer to string
  alloc 8 itos_acc // buffer
| extern sprintf
| pop rdx         ; integer to tranform
  @itos_acc
| pop rdi         ; buffer
  "%d"
| pop rsi         ; format
| xor rax, rax    ; no more args
| call sprintf
  @itos_acc
end


// Print functions

proc printi int ()
| extern printf
  "%d"
| pop rdi         ; format
| pop rsi         ; number to print
| xor rax, rax    ; no more args
| call printf 
end

proc printni int ()
| extern printf
  "%d\n"
| pop rdi         ; format
| pop rsi         ; number to print
| xor rax, rax    ; no more args
| call printf 
end

proc prints str ()
| extern printf
    "%s"
| pop rdi         ; format
| pop rsi         ; number to print
| xor rax, rax    ; no more args
| call printf 
end

proc printns str ()
| extern printf
  "%s\n"
| pop rdi         ; format
| pop rsi         ; number to print
| xor rax, rax    ; no more args
| call printf 
end

proc puts (~) ()
| extern puts
| pop rdi
| call puts
end


///////////////////////////////////////////////////////////////////////////////

// Operations

proc add (int, int) int
| pop rax
| pop rbx
| add rax, rbx
| push rax
end
 
proc sub (int, int) int
| pop rbx
| pop rax
| sub rax, rbx
| push rax
end

proc mul (int, int) int
| pop rax
| pop rbx
| mul rbx
| push rax
end

proc div (int, int) int
| xor rdx, rdx
| pop rbx
| pop rax
| div rbx
| push rax
end

proc mod (int, int) int
| xor rdx, rdx
| pop rbx
| pop rax
| div rbx
| push rdx
end

proc succ int int
  1 add
end

proc pred int int
  -1 add
end

proc is_zero int int
  0 eq
end

// Logic

proc eq (int, int) int
| mov rcx, 0
| mov rdx, 1
| pop rax
| pop rbx
| cmp rax, rbx
| cmove rcx, rdx
| push rcx
end

proc either (int, int) int
// Logical or
| pop rax
| pop rbx
| or rax, rbx
| push rax
end
proc or (int, int) int either end

proc both (int, int) int
// Logical and
| pop rax
| pop rbx
| and rax, rbx
| push rax
end
proc and (int, int) int both end

proc not int int
| pop rax
| mov rbx, 1
| xor rax, rbx
| push rax
end

macro compare
| pop rax
| pop rbx
| cmp rax, rbx
end

macro compareI
| pop rbx
| pop rax
| cmp rax, rbx
end

proc gt (int, int) int
| pop rbx
| add rbx, 1
| push rbx
  $compare
| jg _gt_true
| jmp _gt_false
| _gt_true:
    1
  | jmp _gt_end
| _gt_false:
  0
| _gt_end:
  not
end

proc le (int, int) int
  $compareI
| jle _le_true
| jmp _le_false
| _le_true:
    1
  | jmp _le_end
| _le_false:
  0
| _le_end:
end

proc lt (int, int) int
  $compareI
| jl _lt_true
| jmp _lt_false
| _lt_true:
    1
  | jmp _lt_end
| _lt_false:
  0
| _lt_end:
end

proc ge (int, int) int
  $compareI
| jge _ge_true
| jmp _ge_false
| _ge_true:
    1
  | jmp _ge_end
| _ge_false:
  0
| _ge_end:
end



// Syscalls

proc exit int ()
| mov rax, 60
| pop rdi
| syscall
end

